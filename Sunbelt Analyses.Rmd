---
title: "Sunbelt Analyses"
output: html_document
date: "2023-06-23"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load Libraries

```{r}
library(dplyr)
library(ggplot2)
library(descr) 
library(tidyverse)
library(labelled)
library(janitor)
library(pastecs)
library(haven)
library(readstata13)
library(sna)
library(GGally)
library(reshape2)
library(viridis)
library(lme4)
library(sjPlot)
library(MASS)
library(lme4)
library(naniar)
library(lattice)
library(stats)
library(clustMixType)
library(beepr)
library(dendextend)
library(tidytext)
library(factoextra)
library(ggfortify)
library(tidymodels)
library(tidyverse)
```

# Import Data

```{r}
w1_m <- read_dta("Data-Stata/w1_main.dta")
w1_c <- read_dta("Data-Stata/w1_classmate.dta")
w1_a <- read_dta("Data-stata/w1_achievement.dta")
```

```{r preprocess data}
w1_friends <- w1_c |> 
  dplyr::select(youthidCUF, 7:210) |> 
  mutate(y1_bfs_0 = as.numeric(as.character(y1_bfs_0)))

# code out missing values
w1_friends <- w1_friends |> 
  #labelled::to_factor() %>%  # changed labelled/haven_labelled object to factor
  lapply(function(x) as.numeric(as.character(x))) |>  # coerce all vars to be numeric
  data.frame()  

w1_friends[w1_friends < 0] <- NA

var_classes <- sapply(w1_friends, class)

# show the result
var_classes

# exclude the 6 students did not respond to best friends questions at all
descr::freq(w1_c$y1_bfs_0, plot=FALSE)
descr::freq(w1_friends$y1_bfs_0, plot=FALSE)

w1_friends <- w1_friends |> filter(!is.na(y1_bfs_0))
```

```{r reshape data to be long format}

w1_pos_long <- w1_friends |> 
  filter(!is.na(y1_bfs_0)) %>% 
  #filter(!is.na(y1_sit_0)) %>% 
  dplyr::select(youthidCUF, y1_bfs_1:y1_bfs_5) %>% 
  pivot_longer(cols = y1_bfs_1:y1_bfs_5,
               names_to = "best_friends",
               values_to = "friendID") %>% 
  dplyr::select(youthidCUF, friendID) 

length(unique(w1_pos_long$youthidCUF))
```

After getting rid of 6 students who did not respond to bf or sit questions at all

# Calculate Degree Centrality

### Positive Outgoing

Count number of friends listed

```{r count by best friends}
pos_out <- w1_pos_long |> 
  mutate(hasfriend = ifelse(is.na(friendID),0,1)) |> 
  group_by(youthidCUF) |> 
  summarise(pos_outgoing = sum(hasfriend)) |> 
  mutate(youthidCUF = as.character(youthidCUF))

#plot the distribution
descr::freq(pos_out$pos_outgoing, plot = FALSE)
```

### Negative Outgoing

```{r}
w1_neg_long <- w1_friends |> 
  #filter(!is.na(y1_bfs_0)) %>% 
  filter(!is.na(y1_sit_0)) %>% 
  dplyr::select(youthidCUF, y1_sit_1:y1_sit_5) %>% 
  pivot_longer(cols = y1_sit_1:y1_sit_5,
               names_to = "not_sit",
               values_to = "notfriendID") %>% 
  dplyr::select(youthidCUF, notfriendID) 
  

length(unique(w1_neg_long$youthidCUF))

neg_out <- w1_neg_long |> 
  mutate(notfriend = ifelse(is.na(notfriendID),0,1)) |> 
  group_by(youthidCUF) |> 
  summarise(neg_outgoing = sum(notfriend)) |> 
  mutate(youthidCUF = as.character(youthidCUF))


#plot the distribution
descr::freq(neg_out$neg_outgoing, plot = FALSE)
```

### Indegree

```{r}

students <- w1_friends |> 
  filter(!is.na(y1_bfs_0)) %>% 
  filter(!is.na(y1_sit_0)) %>% 
  dplyr::select(youthidCUF)

indegree <- as.data.frame(students) |> 
  mutate(pos_ingoing = 0) |> 
  mutate(neg_ingoing = 0) 
 
colnames(indegree)[1] <- "youthidCUF"
indegree <- indegree |> mutate(youthidCUF = as.character(youthidCUF))

for (i in 1: nrow(indegree)){
  id = indegree[i, 1]
  pos = w1_pos_long %>% filter(friendID == id)
  indegree[i,2] <- dim(pos)[1]
  neg = w1_neg_long |> filter(notfriendID == id)
  indegree[i,3] <- dim(neg)[1]
  # 
  # indegree$pos_in[id] <- dim(w1_reciprocal_long |> filter(friendID == id))[1]
  # indegree$pos_in[id] <- sum(w1_reciprocal_long$friendID == id)
  # indegree$neg_in[id] <- sum(w1_neg_long$notfriendID == id)
}

summary(indegree$neg_ingoing)
summary(indegree$pos_ingoing)
```

```{r}

w1_centrality <- merge(pos_out, neg_out, by = 'youthidCUF')
w1_centrality <- merge(w1_centrality, indegree, by = 'youthidCUF')
```

# Count Reciprocity (n mutual friends, non-reciprocal)

### Count \# of Mutual Friends

```{r count mutual friends}

students <- unique(w1_friends$youthidCUF)
fred_mat <- as.data.frame(students) %>% 
  mutate(reciprocal = 0) |> 
  mutate(non_reciprocal = 0)
colnames(fred_mat)[1] <- "youthidCUF"

#iterate over each student
for (i in 1 : nrow(fred_mat)) {
  id = fred_mat[i,1]
  #create data table that has that student's nominations:
  dt = w1_pos_long %>% filter(youthidCUF == id)
  #create a list of the IDs that student listed:
  bfs = unique(dt$friendID)
  #iterate over each id the student listed
  for (bf in bfs) {
    bf_data = w1_pos_long %>% filter(youthidCUF == bf)
    if (id %in% unique(bf_data$friendID)){
      fred_mat[i,2] = fred_mat[i,2] + 1
      } 
    else if (! id %in% unique(bf_data$friendID)){
      fred_mat[i,3] = fred_mat[i,3] + 1
    }
    else {next}
  }
}

descr::freq(fred_mat$reciprocal)
descr::freq(fred_mat$non_reciprocal)

n_distinct(fred_mat$youthidCUF)
fred_mat <- fred_mat |>mutate(youthidCUF = as.character(youthidCUF))
```

### Merge network variables:

```{r merge }

d_networks <- merge(w1_centrality, fred_mat, by = 'youthidCUF') |> 
  rename(neg_indegree = neg_ingoing,
         pos_indegree = pos_ingoing,
         neg_outdegree = neg_outgoing,
         pos_outdegree = pos_outgoing)

d_networks <- d_networks |> 
  mutate(pos_isolate = ifelse(pos_indegree == 0 & pos_outdegree == 0, 1, 0),
         neg_isolate = ifelse(neg_indegree == 0 & neg_outdegree == 0, 1, 0)) 

#***Crosscheck numbers with w1_friends data
d_networks |> filter(pos_outdegree == 0) |> count()
w1_friends |> filter(y1_bfs_0 == 1) |> count()
d_networks |> filter(pos_isolate == 1) |> count()


d_networks |> filter(neg_outdegree == 0) |> count()
w1_friends |> filter(y1_sit_0 == 1) |>  count()
d_networks |> filter(neg_isolate == 1) |> count()

write_csv(d_networks, "Data-Stata/our_data/d_analysis_326.csv")

```

```{r}
covars <- c("youthidCUF","classidCUF","schoolidCUF","schtype_geRV","y1_sex","y1_doby", "y1_migage", "y1_nationRV","y1_fact","y1_sat2","y1_sat1","y1_date", "y1_iseimG", "y1_iseifG")


#add class size to use as a class-level predictor
main1 <- w1_m[covars]
class_size <- main1 |> 
  group_by(classidCUF) |> 
  summarize(class_size = n()) |> 
  ungroup()

main1 <- main1 |> 
  left_join(class_size, by = "classidCUF")


main1 <- merge(main1, d_networks, by = "youthidCUF")

scores <- w1_a |> 
  dplyr::select(classidCUF, youthidCUF, y1_cot_sum, y1_lat_sum)


main <- merge(main1, scores)

main <- main |> 
  filter(y1_sat2>0) 



```

Check normality:

```{r}
shapiro.test(main$y1_sat2) # p-value < 0.05 implying that the distribution of the outcome are significantly different from normal

# create a Q-Q plot
qqnorm(main$y1_sat2)
hist(main$y1_sat2)

```

Rename variables, change classes, create coariates

```{r}
main <- main |> 
  mutate_at(vars(setdiff(covars, 'y1_migage')), ~ ifelse(. < 0, NA, .))

d_clean <- main |> 
  #create additional covariates:  
  #create age variable
  mutate(age = 2010 - main$y1_doby) |> 
  #create immigrant variable
  mutate(immigrant = if_else(y1_migage < 0, 0, 1)) |> 
  # change gender/ nationality / school type as factor
  mutate(sex = as.factor(y1_sex),
         schooltype = as.factor(schtype_geRV),
         nationality = as.factor(y1_nationRV),
         ISEI_mom = y1_iseimG,
         ISEI_dad = y1_iseifG,
         age = as.numeric(age),
         class_size = as.numeric(class_size),
         sch_satisfaction = as.numeric(y1_sat2),
         lang_test = as.numeric(y1_lat_sum),
         cog_test = as.numeric(y1_cot_sum),
         cog_abil = rowMeans(cbind(y1_cot_sum, y1_lat_sum)),
         ISEI_parent = rowMeans(cbind(ISEI_mom, ISEI_dad), na.rm = TRUE))

d_analysis <- d_clean |> 
  dplyr::select(ISEI_parent, cog_abil, sch_satisfaction, class_size, age,nationality, schooltype, immigrant, sex, youthidCUF, classidCUF, schoolidCUF, pos_indegree, pos_outdegree, pos_isolate, neg_indegree, neg_outdegree, neg_isolate, reciprocal, non_reciprocal) |> na.omit()

```

```{r}
d_variables <- d_clean |> 
  dplyr::select(sex, age, immigrant, schooltype, class_size, lang_test, cog_test, neg_indegree, neg_outdegree, pos_indegree, pos_outdegree, pos_isolate, neg_isolate, reciprocal, non_reciprocal, sch_satisfaction) |> 
  na.omit()


stargazer(as.data.frame(d_variables), type = "text", out = "summarystats.txt",
          title = "Table 1. Descriptive Statistics", digits = 2)
```

Mean-center and dummy code:

```{r}
numeric_vars <- c("age", "class_size", "cog_abil", "ISEI_parent")

d_analysis <- d_analysis |> 
  #mutate(across(numeric_vars, ~ as.numeric(.))) |> 
  #mutate(across(numeric_vars, ~. - mean(., na.rm = TRUE))) |> 
  mutate_at(vars(all_of(numeric_vars)), as.numeric)  |> 
  mutate_at(vars(all_of(numeric_vars)), scale) |> 
  mutate(german = if_else(nationality == 3, 0, 1)) |> 
  mutate(sch_combo = if_else(schooltype == 2, 1, 0)) |> 
  mutate(sch_int = if_else(schooltype==3, 1, 0)) |> 
  mutate(sch_comp = if_else(schooltype==4, 1,0)) |> 
  mutate(sch_secondary = if_else(schooltype==5, 1,0)) |> 
  mutate(sch_specneed = if_else(schooltype==6, 1,0)) |> 
  mutate(sexgirl = if_else(sex == 2, 1, 0))


# Remove attributes from columns
d_analysis <- data.frame(lapply(d_analysis, unclass)) |> 
  dplyr::select(-c(sex, nationality))
```

```{r}
factor_vars <- c("pos_isolate", "neg_isolate", "immigrant", "sexgirl", "youthidCUF", "classidCUF", "schoolidCUF", "german", "sch_combo", "sch_int", "sch_comp", "sch_secondary", "sch_specneed")

d_analysis <- d_analysis |> 
  mutate_at(vars(all_of(factor_vars)), as.factor) 

write_csv(d_analysis, "Data-Stata/our_data/d_analysis_sunbelt.csv")

```

# Cluster Analysis on network measures

```{r}
d_analysis <- read_csv("Data-Stata/our_data/d_analysis_sunbelt.csv") |> 
  na.omit()

d_cluster <- d_analysis |> 
  dplyr::select(neg_indegree, neg_outdegree, pos_indegree, pos_outdegree, pos_isolate, neg_isolate, non_reciprocal, reciprocal) 

d_cluster_z <- d_cluster |> 
    mutate(across(-c(pos_isolate, neg_isolate), scale))
```

### K-means clustering

run k-means model for 1-15; collect within-cluster sum of squares and plot scree plot:

```{r}
set.seed(1234)

tibble(k = 1:15) |>
  mutate(kmeansmod = map(k, ~ kmeans(d_cluster_z, 
                             .x,
                             nstart = 25,
                             iter.max = 1000)),
         glanced = map(kmeansmod, glance)) |>
  unnest(cols = c(glanced)) |>
  ggplot(aes(k, tot.withinss)) +
  geom_line() +
  geom_point()

```

No clear elbow; let's just use k = 5 for now

#### Create Clusters:

```{r}
set.seed(1234)
network_clusters <- kmeans(d_cluster_z, 
                        centers = 6, 
                        nstart = 25)

network_clusters

tidy(network_clusters)

network_clusters_4 <- kmeans(d_cluster_z,
                             centers = 4,
                              nstart = 25)

network_clusters$cluster
# k = 3
# my_clusters <- kmeans(d_cluster_z, k)
```

#### Plot Results

```{r}
tidy(network_clusters) |>
  mutate(cluster = str_c("cluster_", 1:6)) |>
  pivot_longer(cols = -c(cluster, withinss, size),
               names_to = "Variable",
               values_to = "Value") |>
  mutate(importance = Value * Value) |>
  group_by(cluster) |>
  slice_max(importance, n = 10) |>
  ungroup() |>
  mutate(cluster = as.factor(cluster),
         Variable = reorder_within(Variable,
                                   by = importance,
                                   within = cluster)) |>
  ggplot() +
  geom_col(aes(y = Value, 
               x = Variable,
               fill = Variable)) +
  facet_wrap(~ cluster, 
             nrow = 2,
             scales = "free_y") + 
  guides(fill = "none") +
  scale_x_reordered() +
  coord_flip()

```

plot clusters on principal components. autoplot will return the clusters plotted on the first two principal components

```{r}
autoplot(network_clusters, 
         d_cluster_z, 
         alpha = 0.5)  +
  scale_color_discrete(breaks=c("1", "2", "3", "4", "5"))
```

Looks like it's not doing a great job...

## Correlation

Let's take a look at the correlation heatmaps:

```{r}
# Prepare your data with categorical variables as factors and numerical variables as numeric
# For example:
numerical_vars <- c("neg_indegree", "neg_outdegree", "pos_indegree", "pos_outdegree", "reciprocal", "non_reciprocal")  # Categorical variable names
categorical_vars <- c("pos_isolate", "neg_isolate")  # Numerical variable names
#round(cor(d_analysis[,-1], use = "pairwise.complete"),2)
round(cor(d_cluster_z[,numerical_vars], use = "pairwise.complete"),2)
corrplot(cor(d_cluster_z[,numerical_vars], use="complete.obs"), order = "hclust", tl.col='black', tl.cex=.75) 
```

## K-Proto Clustering

The kproto() function allows us to do k-prototypes algorithm (allows you to update the cluster centroids for continuous variables using the means and updating the cluster modes for binary variables using the mode.) We have both continuous and factor vars, so we use this method

First, determine how many k to use

```{r}

# Combine categorical and numerical variables into a single data frame
d_proto <- data.frame(d_cluster_z[, categorical_vars], d_cluster_z[, numerical_vars]) %>%
  mutate(pos_isolate = as.factor(pos_isolate), neg_isolate = as.factor(neg_isolate))


k_values <- 1:15

# Create an empty vector to store the total within-cluster sum of squares
tot_withinss <- numeric(length(k_values))

# Perform k-prototypes clustering for each value of k and calculate the total within-cluster sum of squares
for (k in k_values) {
  kproto_result <- kproto(d_proto, k, nstart = 25)
  tot_withinss[k] <- kproto_result$tot.withinss
}

# Plot the total within-cluster sum of squares
plot(k_values, tot_withinss, type = "b", pch = 19, frame = FALSE, xlab = "Number of Clusters (k)", ylab = "Total Within-Cluster Sum of Squares", main = "Total Within-Cluster Sum of Squares vs. Number of Clusters")

```

Not very clear... let's go for 6?

```{r}

# Specify the number of clusters (k)
k <- 6

# Perform k-prototypes clustering
kproto_result <- kproto(d_proto, k, nstart = 25)

# Get the cluster assignments
cluster_labels <- kproto_result$cluster

# Get the cluster centroids
cluster_centroids <- kproto_result$centers

# View the cluster assignments
print(cluster_labels)

# View the cluster centroids
print(cluster_centroids)

```

Plot Results

```{r}

cluster_prototypes <- data.frame(
  withinss = kproto_result$withinss,
  size = kproto_result$size,
  kproto_result$centers
) |> 
  rename(cluster = size.clusters, size = size.Freq) |> 
  mutate(pos_isolate = if_else(pos_isolate == '1', 1, 0), neg_isolate = if_else(neg_isolate == '1', 1, 0))

cluster_prototypes |>
  pivot_longer(cols = -c(cluster, withinss, size),
               names_to = "Variable",
               values_to = "Value") |>
  mutate(importance = Value * Value) |>
  group_by(cluster) |>
  slice_max(importance, n = 10) |>
  ungroup() |>
  mutate(cluster = as.factor(cluster),
         Variable = reorder_within(Variable,
                                   by = importance,
                                   within = cluster)) |>
  ggplot() +
  geom_col(aes(y = Value, 
               x = Variable,
               fill = Variable)) +
  facet_wrap(~ cluster, 
             nrow = 2,
             scales = "free_y") + 
  guides(fill = "none") +
  scale_x_reordered() +
  coord_flip()

```

Note: therea re no clusters where mode of isolate measures == 1; this makes sense since there are very few isolates in the df:

```{r}
histogram(d_analysis$pos_isolate)
histogram(d_analysis$neg_isolate)
```

#### Modeling

```{r}
d_analysis <- mutate(d_analysis, cluster = as.factor(cluster_labels)) |> 
  mutate(cluster_labels = case_when(
  cluster_labels == 1 ~ "average",
  cluster_labels == 2 ~ "disliked",
  cluster_labels == 3 ~ "loner",
  cluster_labels == 4 ~ "unreciprocated",
  cluster_labels == 5 ~ "unproblematic",
  cluster_labels == 6 ~ "popular"
))
#rename clusters here according to the typology


#ADD CLASS SIZES/INTERACTIONS!!!!, school type 
m1 <- lmer(sch_satisfaction ~  cluster_labels + sexgirl + cog_abil + age + immigrant + ISEI_parent + (1 | schoolidCUF/classidCUF) + class_size + sch_combo + sch_int + sch_comp + sch_secondary + sch_specneed, data = d_analysis,
          REML = F, na.action = na.omit)
summary(m1)


m2 <- glmer(sch_satisfaction ~  cluster_labels + sexgirl + cog_abil + age + immigrant + ISEI_parent + (1 | schoolidCUF/classidCUF) + class_size + sch_combo + sch_int + sch_comp + sch_secondary + sch_specneed
,  
            data = d_analysis, 
            family = gaussian(link = "log"), 
            na.action = na.omit)
summary(m2)


#this might be most suitable (for left-skewed outcome var:)
m3<- glmer(sch_satisfaction ~  cluster_labels + sexgirl + cog_abil + age + immigrant + ISEI_parent + (1 | schoolidCUF/classidCUF) + class_size + sch_combo + sch_int + sch_comp + sch_secondary + sch_specneed
, family = Gamma(link = "log"), data = d_analysis)
summary(m3)
tab_model(m3)

```

Dealing with non-normality: new (final?) model

```{r}

## Using mixed model with penalized quasilikelihood (PQL) since our data are not normally distributed

m5 <- glmmPQL(sch_satisfaction ~  cluster_labels + sexgirl + cog_abil + age + immigrant + ISEI_parent + class_size, random = ~1 | schoolidCUF/classidCUF, family = Gamma(link = "log"),
    data = d_analysis, verbose = FALSE)
summary(m5)

```

# Visualizations

```{r}
d_analysis |> 
  dplyr::select(sch_satisfaction, neg_indegree, neg_outdegree, pos_indegree, pos_outdegree, reciprocal, non_reciprocal) |>  
  #mutate_at(vars(-c(y1_sat2)), scale) |> 
  pivot_longer(cols = -c(sch_satisfaction),
               names_to = "network_trait", 
               values_to = "value") |> 
  ggplot(aes(y = sch_satisfaction, x = value, color = network_trait)) +
  facet_wrap(~network_trait, labeller = function(variable, value){
    value <- gsub("neg_", "Negative ", value)
    value <- gsub("pos_", "Positive ", value)
    value <- gsub("reciprocal","Reciprocal friends", value)
    value <- gsub("non_reciprocal","Non-reciprocal friends", value)
    return(value)
  }, scales = "free") +
  stat_summary(geom = "line", fun = "mean") +
  scale_color_brewer(palette = "Paired") +
  labs(y = 'Self-Rated School Satisfaction\n(1-10)', x = "Continuous Network Measures", title = 'Continuous Network Characteristics vs School Satisfaction')+
  theme(legend.position = "none")

```

```{r}


d_analysis  |> 
  dplyr::select(pos_isolate, neg_isolate, sch_satisfaction) |>
  pivot_longer(cols = -c(sch_satisfaction),
               names_to = "network_trait",
               values_to = "value") %>%
  ggplot(aes(y = sch_satisfaction, x = value, fill = network_trait)) +
  facet_wrap(~network_trait, labeller = function(variable, value) {
    value <- gsub("neg_", "Negative ", value)
    value <- gsub("pos_", "Positive ", value)
    return(value)
  }, scales = "free") +
  geom_boxplot() +
  scale_fill_brewer(palette = 'Paired')+
  labs(x = 'Isolate Indicators', y = 'School Satisfaction', title = 'Isolate Indicators (Binary) vs School Satisfaction')+
  theme(legend.position = 'none')





# 
# p1box <- ggplot(aes(x = pos_isolate, y = sch_satisfaction), data = d_analysis)+
#   geom_boxplot(fill = 'lightblue')+
#   labs(x = "Positive Isolate Indicator", y = "Mean Satisfaction in School")
# 
# p2box <- ggplot(aes(x = neg_isolate, y = sch_satisfaction), data = d_analysis)+
#   geom_boxplot(fill = 'darkred')+
#   labs(x = "Negative Isolate Indicator", y = "")
# 
# box_plots <- ggarrange(p1box, p2box, ncol = 2) + labs(title ='Isolate Indicators (Binary) vs School Satisfaction')
# box_plots
# 
# 
# 
# 

```

```{r}
ggplot(d_analysis, aes(x = sch_satisfaction))+
  geom_density()+
  labs(x = 'School Satisfaction', y = 'Density', title = "Outcome Variable Distribution")
```

```{r}
d_variables <- d_analysis |> 
  dplyr::select(sexgirl, age, immigrant, ISEI_parent, schooltype, class_size, lang_test, cog_test, neg_indegree, neg_outdegree, pos_indegree, pos_outdegree, pos_isolate, neg_isolate, n_mutual_bfs, non_reciprocal, sch_satisfaction) |> 
  na.omit()
summary(d_variables)

stargazer(as.data.frame(d_variables), type = "text", out = "summarystats.txt",
          title = "Table 1. Descriptive Statistics", digits = 2)



install.packages("table1")
library(table1)
table1(d_variables)
```
